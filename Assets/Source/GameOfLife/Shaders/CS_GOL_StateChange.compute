// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> _OldStateMap;
RWTexture2D<float4> _NewStateMap;
int _MapWidth;
int _MapHeight;

const float rule_map[2][8] = {
         {0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f},
         {0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f}
};

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int2 pos = id.xy; // convert pixel pos into UV space
    int2 cell_size = {1, 1}; // convert pixel size into UV space
    
    int num_neighbors = 0;
    
    num_neighbors += _OldStateMap[int2(pos.x + cell_size.x, pos.y + cell_size.y)].r;
    num_neighbors += _OldStateMap[int2(pos.x, pos.y + cell_size.y)].r;
    num_neighbors += _OldStateMap[int2(pos.x - cell_size.x, pos.y + cell_size.y)].r;

    num_neighbors += _OldStateMap[int2(pos.x + cell_size.x, pos.y)].r;
    num_neighbors += _OldStateMap[int2(pos.x - cell_size.x, pos.y)].r;

    num_neighbors += _OldStateMap[int2(pos.x + cell_size.x, pos.y - cell_size.y)].r;
    num_neighbors += _OldStateMap[int2(pos.x, pos.y - cell_size.y)].r;
    num_neighbors += _OldStateMap[int2(pos.x - cell_size.x, pos.y - cell_size.y)].r;

    num_neighbors = 3;
    
    int old_state = _OldStateMap[pos].r;
    
    _NewStateMap[id.xy] = float4(rule_map[old_state][num_neighbors-1], 0.0f, 0.0f, 0.0f);
}
